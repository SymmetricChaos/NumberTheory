from ModularArithmetic import modinv, residue_points
from PrimeNumbers import is_prime

def elliptic_nonsingular(a,b,field):
    if (4*a**3 + 27*b**2) % field == 0:
        return False
    return True

def elliptic_points(a,b,field):
    
    D = residue_points(field)
    
    out = [(float('inf'),float('inf'))]
    
    for i in range(field):
        Y = (i**3 + a*i + b) % field
        if str(Y) not in D:
            continue
        else:
            for y in D[str(Y)]:
                out.append((i,y))
    return out


class Elliptic_Curve:
    def __init__(self,a,b,f):
        assert elliptic_nonsingular(a,b,f), "Elliptic curves must be non-singular"
        assert is_prime(f), "f must be prime"
        self.a = a
        self.b = b
        self.f = f
        self.identity = Elliptic_Point(float('inf'),float('inf'),self)
    
    def points(self):
        return elliptic_points(self.a, self.b, self.f)
       
    def __eq__(self,other):
        if self.a != other.a or self.b != other.b or self.f != other.f:
            return False
        return True
    
    def copy(self):
        return Elliptic_Curve(self.a,self.b,self.f)
        

class Elliptic_Point:
    def __init__(self,x,y,curve):
        
        if x != float('inf') and y != float('inf'):
            if (y**2) % curve.f != (x**3 + curve.a*x + curve.b) % curve.f:
                raise Exception("Points are not on specified curve")
        
        self.x = x
        self.y = y
        self.coords = (x,y)
        self.curve = curve
    
    def __str__(self):
        return "({},{})".format(self.x,self.y)
      
    def __repr__(self):
        return "({},{})".format(self.x,self.y)
    
    
    def __eq__(self,other):
        
        if self.x == other.x and self.y == other.y:
            if self.curve.a == other.curve.a and self.curve.b == other.curve.b:
                if self.curve.f == other.curve.f:
                    return True
        return False
    
    def inv(self):
        return Elliptic_Point(self.x, (self.curve.f-self.y) % self.curve.f, self.curve)
    
    def __add__(self,other):
        assert self.curve == other.curve, "Points are from different curves"
    
        if self == other.inv():
            return self.curve.identity
        
        # Account for the additive identity
        if self.coords == (float('inf'),float('inf')):
            return other
        if other.coords == (float('inf'),float('inf')):
            return self
    
        if self == other:
            m = (3*self.x*self.x+self.curve.a) * modinv(2*self.y, self.curve.f)
        else:
            m = (self.y-other.y)*modinv( self.x-other.x, self.curve.f )
    
        
        x = (m*m - self.x - other.x) % self.curve.f
        y = -(self.y + m*(x - self.x)) % self.curve.f
        return Elliptic_Point(x, y, self.curve)
    
    def __mul__(self,scalar):
        if scalar == 0:
            return self.curve.identity
        if scalar == 1:
            return self
        else:
            out = self
            for i in range(scalar-1):
                out += self
            return out
        

def cyclic_subgroup(a):
    """The elements of the cyclic subgroup generated by point"""
    G = []
    t = a
    while True:
        G.append(t)
        t = a+t
        if t == a:
            break
    return G

def cyclic_subgroups(C):
    """Use each element of the curve to generate a cyclic subgroup"""
    ps = C.points()
    Gs = []
    
    for i in ps:
        P = Elliptic_Point(i[0],i[1],C)
        Gs.append(cyclic_subgroup(P))

    return Gs